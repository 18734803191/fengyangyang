npm run dev npm run serve执行顺利   $env:NODE_OPTIONS="--openssl-legacy-provider"
set-ExecutionPolicy RemoteSigned   在shell命令执行在VScode终端可以使用命令
配置vue组件快捷方式https://blog.51cto.com/u_12471633/4626312
https://www.csdn.net/tags/OtDakg1sODM5NTEtYmxvZwO0O0OO0O0O.html   Vue 3 Snippets插件  vetur插件代码高亮
ctrl+c终止终端运行命令
vue组件命名name值驼峰命名法或者vue.config配置lintonsave ：false
 npm i vue-router@3.2.0
 npm i less-loader@5.0.0
 npm i less
 cd ..返回上一级
npm cache clear -force 清除npm缓存
yarn config set ignore-engines true   在终端yarn报错
-----------------------------------------
在安装vue-router的时候报错，我是vux或者@3.6.2没有试过需要指定
npm ERR! code ERESOLVE
npm ERR! ERESOLVE unable to resolve dependency tree
百度翻译了一下：
npm错误！代码解析
npm错误！ERESOLVE无法解析依赖关系树
查阅相关资料后说原因是：安装的包与已经存在的包有冲突。
解决方法：
使用npm install xxx -- force或者npm install xxx --legacy-peer-deps来安装。 作者：丘奇小怪 https://www.bilibili.com/read/cv15732729/ 出处：bilibili	
----------------------------------------------------------------------------------------------------------------------------------------------------------
1 vue中key的作用和原理                                                 
推荐使用数据的唯一标识作为key
key在Vue是DOM对象的标识；
进行列表展示时，默认key是index；
如果数据只做展示使用，使用index作为key是没有任何问题的；
如果使用index作为key，而后续操作会破坏顺序，一定会带来效率问题，严重时会渲染出错误的DOM
   1.2. key的作用
key就是一个标识，被使用在Vue中。再详细一点，key被使用在Vue中的虚拟DOM中，并不会出现在真实DOM中
我们可以得到两个结论：1. 只做数据展示用，不写key是没有任何影响的；2.key不会出现在真实DOM中
实际上，即使不写key，Vue在生成真实DOM时，也用到了key，默认是数据索引（index）
我们把key替换为index，展示的数据不会产生任何改变。
   1.3. key的实现原理
要解释key的实现原理，就要引入Vue一个十分重要的概念——【虚拟DOM】。
给出一组数据，Vue要把这些数据渲染到页面上，首先要生成【虚拟DOM】，然后根据【虚拟DOM】去生成【真实的DOM】。如果数据发生了改变，Vue会生成【新的虚拟DOM】，注意，这个【新的虚拟DOM】并不会直接生成【新的真实DOM】，否则虚拟DOM一点用处也没有了。Vue的操作是，拿根据新的数据生成的【新的虚拟DOM】与之前的【真实的DOM】去做比较，如果相同，直接延用即可（“拿来主义”）；如果不同，则生成新的DOM对象。
在这个过程中key扮演了很重要的角色。
————————————————
版权声明：本文为CSDN博主「纸照片」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/cun_king/article/details/120714227
-------------------------------------------------------------------------------------------------------------------------------------
2 组件中name的作用
作用一：递归组件
一个组件要用自己的时候，可以通过自己的名字来使用自己。
作用二：移除keep-alive状态下组件自动缓存功能 -> exclude=“name”。include做组件筛选，name缓冲过滤
作用三：浏览器使用vue-tools调试时
vue-devtools调试工具里显示的组件名称是由vue中组件name决定的
-----------------------------------------------------------------------------------------------------------------------------------------
3 vue-router 中的钩子函数主要分为 3 类
1、全局钩子函数要包含 beforeEach
1,1）beforeEach 函数有三个参数,分别是
 1,2）to:router 即将进入的路由对象
 1,3）from:当前导航即将离开的路由
 1,4）next:function,进行管道中的一个钩子，如果执行完了,则导航的状态就是 confirmed
（确认的）否则为 false,终止导航
————————————————
版权声明：本文为CSDN博主「ling…」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/chai_tian/article/details/119613080
2、单独路由独享组件
2,1）beforeEnter
 3、组件内钩子
3,1）beforeRouterEnter
3,2）beforeRouterUpdate
3,3）beforeRouterLeave
----------------------------------------------------------------------------------------------------------------------------------------
计算属性支持缓冲不支持异步，watch有异步无缓冲，computed有缓冲无异步
---------------------------------------------------------------------------------------------------------------------------------------
vue中scoped的原理
在vue文件中的style标签上，有一个特殊的属性：scoped。当一个style标签拥有scoped属性时，它的CSS样式就只能作用于当前的组件，也就是说，该样式只能适用于当前组件元素。通过该属性，可以使得组件之间的样式不互相污染。如果一个项目中的所有style标签全部加上了scoped，相当于实现了样式的模块化。
还拥有一种曲线救国的方法，即在定义一个含有scoped属性的style标签之外，再定义一个不含有scoped属性的style标签，即在一个vue组件中定义一个全局的style标签，一个含有作用域的style标签
scoped看起来很美，但是，在很多项目中，会出现这么一种情况，即：引用了第三方组件，需要在组件中局部修改第三方组件的样式，而又不想去除scoped属性造成组件之间的样式污染。此时只能通过特殊的方式，穿透scoped。
<style scoped>
 外层 >>> 第三方组件 {
  样式
 }
</style>
通过 >>> 可以使得在使用scoped属性的情况下，穿透scoped，修改其他组件的值
--------------------------------------------------------------------------------------------------------------------------------------
1、null与undefined的异同点是什么呢？
共同点：都是原始类型，保存在栈中变量本地
不同点：
（1）undefined——表示变量声明过但并未赋过值。
它是所有未赋值变量默认值。
例如：var a; //a自动被赋值为undefined
（2）null——表示一个变量将来可能指向一个对象。
一般用于主动释放指向对象的引用。
-----------------------------------------------------------------------------------------------------------------------------------------
2.Vue的优缺点有哪些？

- 优点
  - 轻量 双向数据绑定 指令 插件化 渐进式灵活 组件系统 自底向上灵活应用 只关心数据 第三方整合 Vue全家桶
- 缺点
  - vue应用是单页面应用，不利于seo优化，需要在服务端做seo
  - 前进后退功能需要使用程序进行处理
  - 初次加载耗时比较多，因为第一次加载就需要把所有的html css js加载完成
----------------------------------------------------------------------------------------------------------------------------------------
3.单页面应用（SPA）与多页面应用（MPA）的区别有哪些？

- 单页面应用：
  - 只有一个html页面 ，比如vue ，只有一个index.html
- 多应用页面：
  - 由多个html组成
- 区别
  - 多页面应用：	
    - 每次页面跳转，服务器都会返回一个新的html文档
    - 首次加载快
    - 利于seo优化
    - 页面切换慢，因为每次跳转都需要发送一个http请求
  - 单页面应用
    - 页面切换快
    - 首次加载慢
    - 不利于seo
    - 前进后退管理需要插件处理
    - 可以减轻服务器压力
    - 前后端工作分离
------------------------------------------------------------------------------------------------------------------------------------
 4.v-if与v-for谁的优先级更高？如何正确使用避免性能浪费？

- v-for的优先级更高，在指令解析源码中v-for优先于v-if编译
- 可以将v-if条件判断写在template上，先判断条件，再执行循环，这样就解决了性能浪费的问题
- 如果必须在同一个位置使用v-if v-for ，那么可以使用计算属性过滤掉不需要不符合条件的项，往往for循环中的数据都是可以渲染的
------------------------------------------------------------------------------------------------------------------------------------
5.vue组件中的data为什么是一个函数？而App.vue却是一个对象？
- vue组件中的data是函数是因为，vue中的组件是多个的，如果多个组件使用同一个对象，就会造成数据共用，只要其中一个组件修改了数据，必然会影响另一个组件，这是不合理的。把data写成函数式，在data选项加载时（initData）就会通过一个工厂函数getData(vm,vm)，处理函数中的数据，这样每个实例的data数据都是独立的，避免了互相污染。
- App.vue是唯一的，所以不需要担心数据共用，并且在vue处理合并选项时，根实例会多一个vm实例参数，不会走data类型检测。如果是一个普通的组件，就必须走data类型检测了。
-----------------------------------------------------------------------------------------------------------------------------------
7.你是怎么理解vue的diff算法的？

- diff算法是虚拟DOM技术的必然产物，通过对比两颗新旧虚拟DOM树（diff），将变化的地方更新在真实dom上，就必须使用diff，降低时间的复杂度。不使用diff，时间复杂度为O(n)的3次方，使用diff，时间复杂度为O(n)
- 在vue2.x中，降低了watcher的粒度，一个组件只有一个对应的watcher，那么在变化更新的时候怎么找到哪里变化了呢？这里就必须使用diff算法了
- diff算法的过程整体遵循：深度优先，同层比较（因为我们开发的时候不会将dom跨层级操作）
- vue中的diff算法添加了4个邮标，会进行首尾比较，所以在使用vue的时候绑定唯一的key，可以增加vue的工作效率

### 38.谈一谈你对vue组件化的理解

- 组件是独立可复用的代码块。组件系统是vue的核心特性之一
- 组件化开发可以大幅度的提高开发效率，测试性，复用性等等，开发团队也比较易于协调
- 组件分类有
  - 页面组件
    - 用路由导航的页面，复用性不高
  - 业务组件
    - 登陆注册，购物车等等，具有很强的业务性，同时又具有复用性
  - 通用组件
    - 按钮，表单，输入框等等
- 高内聚
  - 分治思想的落地，一个组件只负责自己该干的事，单一独立，更易于复用
- 低耦合
  - 不与其他组件有过多的关联

### 39.你常用的组件化技术有哪些？

- 属性props
- 自定义事件$emit
- 插槽slot
- 混入mixing
- 渲染Render

### 40.vue中是如何定义组件的？

- 全局注册
  - vue.component()
  - Vue.extends()   组件构造器    ？？？
- 局部注册. 父组件中使用
  - Components

### 41.请谈一下你对vue设计原则的理解

- vue是渐进式框架，自底向上逐层应用。
  - vue的核心库是 ，声明式渲染，组件系统，只关注视图层，容易上手
- 易用性
  - vue提供数据响应化，声明式模版语法和基于配置的组件系统核心特性，这些使开发者只关心核心业务
- 灵活性
  - 随着应用的规模扩大，我们才可能引入vue-router  ， vuex ， vue-cli等等工具，不管是应用还是学习难度，都是逐渐增加的
- 高效性
  - 虚拟dom和diff算法应用拥有最佳的性能表现
  - vue3中引入了proxy对数据响应式进行了改进，以及编译器对静态内容的编译改进都会让vue更加高效

### 42.你对vue3.0新特性有了解吗？

- 虚拟dom重写
- 基于Proxy的响应式系统
- 使用ts重写

### 43.你在工作中常用的git命令有哪些？

- git add.
- git commit -m 
- git push
- git checkout -b 
- git merge
- git pull

### 44.CSS选择器有哪些？

- id选择器 ，class类选择器，标签选择器，属性选择器，后代选择器，子代选择器，并集选择器
- 伪类选择器，伪元素选择器

### 45.CSS的样式权重优先级是怎么计算的？

- !iimportant > 行内样式 > id > class = 伪类 = 属性 > 标签 > * > 继承

### 46.JS的执行机制是什么？

- JS是单线程语言，一次只能执行一个任务，所有的任务都需要排队，排队的队列叫做：事件循环Event Loop，所以Event Loop就是js的执行机制
- js单线程
  - js作为浏览器脚本语言，主要用来与用户进行交互，需要进行dom操作，为了避免了同时操作DOM的矛盾，所以js是单线程的

### 47.JS为什么需要异步？

- 因为js是单线程语言，所有任务都需要排队，一次只能执行一个任务，如果上一个任务执行事件很长，后面的任务就必须一直处于等待状态，。
- 如果js不存在异步，只能从上往下执行，如果任务执行时间长，就会造成线程阻塞，对于用户而言，就以为这卡死，会导致用户体验很差。所以需要js异步

### 48.JS任务队列是什么？

- 任务队列就是一个事件队列，其中最重要的是异步任务事件和定时任务事件
  - 异步任务事件（在某一个时刻才会被触发）
    - 点击事件的回调函数
  - 定时任务事件
    - setInterval setTimeout

### 49.JS的同步任务和异步任务你是怎么理解的？

- 同步任务
  - 在主线程执行栈上排队执行的任务，只有前一个执行完毕，才能执行后一个
- 异步任务
  - 不进入主线程执行栈，而是进入“任务队列”中的任务，只有在同步任务执行完之后，才会执行异步任务

### 50.你是怎么理解宏任务和微任务的？

- 宏任务与微任务都是异步任务，都是在同一个任务队列中，主要区别在于它们的执行顺序
- 在异步任务队列下 ，又分为宏任务队列与微任务队列
- 当一个宏任务执行结束之前，会在微任务队列执行栈中查找是否有微任务，如果有则执行，没有则开启一个新的宏任务，所以微任务总是在宏任务结束之前执行的
- 宏任务
  - 整体script，setTimeout，setInterval，setImmediate
  - 微任务promise  MutationObserver
-----------------------------------------------------------------------------------------------------------------------------------
3.vue的父组件和子组件的生命周期钩子执行顺序？

- 父加载->子加载->子渲染->父渲染->
  - 父beforeCreate -> 父created -> 父beforeMount -> 子beforCreate -> 子created -> 子beforMount -> 子mouted -> 父mouted
- 父更新之前 -> 子更新之前 -> 子更新 -> 父更新
  - 父beforUpdate -> 子beforUpdate -> 子updated -> 父updated
- 父销毁之前 -> 子销毁之前 -> 子销毁 -> 父销毁
  - 父beforDestroy -> 子beforDestroy -> 子destroyed -> 父destroyed
-------------------------------------------------------------------------------------------------------------------------------------
4.你一般在哪个声明周期里调用异步请求？

- 可以在created ，beforMount ，mounted 这3个钩子中调用异步请求
- created是最早可以访问data的钩子，mouted是最早可以访问dom的钩子
- 我一般在mouted里调用异步请求，如果团队有要求可以按照团队来执行
----------------------------------------------------------------------------------------------------------------------------------
5.谈一谈你对keep-alive的理解

- keep-alive是vue内置的一个组件，用来缓存组件，避免在组件重新激活后再次渲染
- 一般是结合动态组件来使用，有两个对应的生命钩子，activated（当组件激活时调用），deactivated（当组件失活时调用）
- 提供 include 与 exclude 属性，exclude的优先级比include高
  - include ： 匹配名称的组件才会被缓存
  - exclude： 匹配名称的组件都不会被缓存
-------------------------------------------------------------------------------------------------------------------------------------
9.vue-router有几种模式？vue-router的实现原理是什么？

- 3种， hash（哈希模式），history（历史模式），abstract（抽象模式）
- hash
  - 使用url中的哈希值来做路由跳转路径，#号之后的都是哈希值
- history
  - 没有#号，需要后端配合，否则可能会出现静态资源无法加载的情况
- 实现原理
  - hashchange监听url的变化，映射指定的组件并渲染
  - history是通过H5提供的History API 来实现路由变化的
------------------------------------------------------------------------------------------------------------------------------------
0.vue是如何实现双向绑定的？

- 核心是使用了Object.definProperty()  vue3.0改为proxy
- 在初始化data(initData)时，会将data作为对象传递给监听器Observer，Observer会遍历data中的每一个key，包括深层嵌套的key（对象中的对象），在遍历的过程中会使用Object.definProperty为每一个key做数据拦截，设置get于set，当初次渲染时会触发get ， 在get中收集依赖，数据变更时会触发set，set中会调用dep通知依赖（watcher）进行更新（update）
- 采用的是发布订阅的设计模式

### 61.vue是如何实现对数组的数据监听的？

- 数组无法使用Object.definProperty， vue的方法是将可改变数组的7个方法进行劫持，并且重写了数组的原型
- 在每次触发这7个方法时，都会执行重写的原型，进行通知依赖更新 
- push shift unshift pop splice sort reverse 

### 62.proxy对比Object.definProperty的优势是什么？

- Proxy可以直接监听整个对象，而Object.definProperty需要递归遍历对象中的每一个成员
- Proxy可以直接监听数组，而Object.definProperty需要劫持数组的7个方法做数据响应和更新通知
-------------------------------------------------------------------------------------------------------------------------------------
5.HTTP与HTTPS有什么区别？

- HTTP是网络上应用最广泛的一种网络协议，是客户端与服务端通信的标准（TCP），HTTP是明文传输的
- HTTPS是以安全为目标的HTTP通道，简单来讲HTTPS就是HTTP的安全版，即在HTTP下加入了SSL协议，用于对HTTP协议传输进行加密
- 主要区别是
  - HTTPS需要申请证书，需要收费
  - HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的SSL加密传输协议
  - HTTP使用的端口是80 ，HTTPS使用的端口是443
  - HTTP是无状态链接的，HTTPS则需要进行身份认证
------------------------------------------------------------------------------------------------------------------------------------
104.比较typeof与instanceof？

- 相同点
  - typeof与instanceof都是用来判断一个变量是否为空，或者判断是什么数据类型
- 不同点
  - typeof返回一个字符串，用来说明变量的数据类型
  - instanceof返回一个布尔值，用来判断一个变量是否属于某个对象的实例
- typeof一般用来检测基本数据类型，instanceof一般用来检测引用数据类型
------------------------------------------------------------------------------------------------------------------------------------
105.你在使用JS的时候遇到了什么坑？

- 1· 获取DOM的时候提示无法获取
  - 原因是：我把JS文件放在了head标签中，而HTML是从上到下顺序执行，所以就拿不到DOM
  - 解决办法是：在script标签中添加defer=‘true’属性，延迟加载，或者把JS放到body之后
- 2· 在使用new Data设置日期格式的时候，发现无论怎么设置月份都会+1
  - 原因是：JS中的月份从0开始
  - 解决办法：把月份-1